import React, { useState, useRef, useEffect } from 'react';
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";

const VoiceChatRoom = () => {
  const [showJoinForm, setShowJoinForm] = useState(true);
  const [name, setName] = useState('');
  const [roomLink, setRoomLink] = useState('');
  const [participants, setParticipants] = useState([]);
  const [isConnected, setIsConnected] = useState(false);
  
  const ws = useRef(null);
  const peerConnection = useRef(null);
  const localStream = useRef(null);
  const reconnectTimeout = useRef(null);

  useEffect(() => {
    initializeWebSocket();
    return () => cleanup();
  }, []);

  const initializeWebSocket = () => {
    try {
      const roomId = new URLSearchParams(window.location.search).get('room') || 
                     Math.random().toString(36).substring(2, 15);
      setRoomLink(`${window.location.origin}${window.location.pathname}?room=${roomId}`);
      
      ws.current = new WebSocket('wss://signal-v2-6203u5gsn-cullen-harrisons-projects.vercel.app');
      
      ws.current.onopen = () => {
        console.log('WebSocket connected');
        setIsConnected(true);
        if (reconnectTimeout.current) {
          clearTimeout(reconnectTimeout.current);
          reconnectTimeout.current = null;
        }
      };
      
      ws.current.onmessage = handleMessage;
      
      ws.current.onerror = handleWebSocketError;
      
      ws.current.onclose = handleWebSocketClose;
    } catch (error) {
      console.error('WebSocket initialization failed:', error);
      scheduleReconnect();
    }
  };

  const handleWebSocketError = (error) => {
    console.error('WebSocket error:', error);
    setIsConnected(false);
    scheduleReconnect();
  };

  const handleWebSocketClose = (event) => {
    console.log('WebSocket closed:', event);
    setIsConnected(false);
    if (!event.wasClean) {
      scheduleReconnect();
    }
  };

  const scheduleReconnect = () => {
    if (!reconnectTimeout.current) {
      reconnectTimeout.current = setTimeout(() => {
        initializeWebSocket();
      }, 5000);
    }
  };

  const handleJoin = async () => {
    if (!name || !isConnected) return;
    
    try {
      localStream.current = await navigator.mediaDevices.getUserMedia({ audio: true });
      setShowJoinForm(false);
      
      const roomId = new URLSearchParams(window.location.search).get('room');
      ws.current?.send(JSON.stringify({
        type: 'join',
        name: name,
        room: roomId
      }));

      setParticipants([{ name }]);
      setupPeerConnection();
      
    } catch (error) {
      console.error('Error accessing microphone:', error);
      alert('Unable to access microphone. Please check permissions.');
    }
  };

  const setupPeerConnection = () => {
    const configuration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    peerConnection.current = new RTCPeerConnection(configuration);

    // Add local stream tracks to peer connection
    localStream.current.getTracks().forEach(track => {
      peerConnection.current.addTrack(track, localStream.current);
    });

    peerConnection.current.ontrack = handleRemoteStream;
    peerConnection.current.onicecandidate = handleICECandidate;
    peerConnection.current.oniceconnectionstatechange = handleICEConnectionStateChange;

    createOffer();
  };

  const handleRemoteStream = (event) => {
    const remoteAudio = new Audio();
    remoteAudio.srcObject = event.streams[0];
    remoteAudio.play();
  };

  const handleICECandidate = (event) => {
    if (event.candidate && ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify({
        type: 'candidate',
        candidate: event.candidate,
        room: new URLSearchParams(window.location.search).get('room')
      }));
    }
  };

  const handleICEConnectionStateChange = () => {
    if (peerConnection.current) {
      console.log('ICE Connection State:', peerConnection.current.iceConnectionState);
      if (peerConnection.current.iceConnectionState === 'failed') {
        peerConnection.current.restartIce();
      }
    }
  };

  const createOffer = async () => {
    try {
      const offer = await peerConnection.current.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: false
      });
      await peerConnection.current.setLocalDescription(offer);

      ws.current?.send(JSON.stringify({
        type: 'offer',
        offer: offer,
        room: new URLSearchParams(window.location.search).get('room')
      }));
    } catch (error) {
      console.error('Error creating offer:', error);
    }
  };

  const handleMessage = async (event) => {
    const message = JSON.parse(event.data);

    switch (message.type) {
      case 'userJoined':
        setParticipants(prev => [...prev, { name: message.name }]);
        break;
      case 'userLeft':
        setParticipants(prev => prev.filter(p => p.name !== message.name));
        break;
      case 'offer':
        await handleOffer(message.offer);
        break;
      case 'answer':
        await handleAnswer(message.answer);
        break;
      case 'candidate':
        await handleCandidate(message.candidate);
        break;
    }
  };

  const handleOffer = async (offer) => {
    try {
      await peerConnection.current.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await peerConnection.current.createAnswer();
      await peerConnection.current.setLocalDescription(answer);

      ws.current?.send(JSON.stringify({
        type: 'answer',
        answer: answer,
        room: new URLSearchParams(window.location.search).get('room')
      }));
    } catch (error) {
      console.error('Error handling offer:', error);
    }
  };

  const handleAnswer = async (answer) => {
    try {
      await peerConnection.current.setRemoteDescription(new RTCSessionDescription(answer));
    } catch (error) {
      console.error('Error handling answer:', error);
    }
  };

  const handleCandidate = async (candidate) => {
    try {
      await peerConnection.current.addIceCandidate(new RTCIceCandidate(candidate));
    } catch (error) {
      console.error('Error handling ICE candidate:', error);
    }
  };

  const cleanup = () => {
    if (localStream.current) {
      localStream.current.getTracks().forEach(track => track.stop());
    }
    if (peerConnection.current) {
      peerConnection.current.close();
    }
    if (ws.current) {
      ws.current.close();
    }
    if (reconnectTimeout.current) {
      clearTimeout(reconnectTimeout.current);
    }
  };

  const copyLink = () => {
    navigator.clipboard.writeText(roomLink);
  };

  return (
    <div className="min-h-screen bg-zinc-800 text-white p-4">
      <div className="max-w-4xl mx-auto">
        {!showJoinForm && (
          <div className="flex items-center gap-4 justify-center mb-8">
            <input
              type="text"
              value={roomLink}
              readOnly
              className="bg-zinc-700 p-2 rounded w-96 text-white"
            />
            <button
              onClick={copyLink}
              className="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded"
            >
              Copy Link
            </button>
          </div>
        )}
        
        <div className="flex flex-wrap gap-4 justify-center">
          {[...Array(12)].map((_, i) => (
            <div
              key={i}
              className={`w-36 h-36 rounded-lg relative flex items-center justify-center ${
                participants[i] ? 'bg-zinc-600' : 'bg-zinc-700 opacity-70'
              }`}
            >
              {participants[i] && (
                <div className="absolute -bottom-6 text-center w-full">{participants[i].name}</div>
              )}
            </div>
          ))}
        </div>

        {showJoinForm && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
            <div className="bg-zinc-700 p-6 rounded-lg shadow-lg">
              <input
                type="text"
                placeholder="Enter your name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="bg-zinc-600 p-2 rounded mb-4 w-full text-white"
              />
              <button
                onClick={handleJoin}
                disabled={!isConnected}
                className="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded w-full disabled:opacity-50"
              >
                Join Room
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default VoiceChatRoom;